/**
 * 运算符
 */

/*
    1，算数运算符：
        加法运算符：x + y
        减法运算符： x - y
        乘法运算符： x * y
        除法运算符：x / y
        指数运算符：x ** y
        余数运算符：x % y
        自增运算符：++x 或者 x++
        自减运算符：--x 或者 x--
        数值运算符： +x
        负数值运算符：-x


     2，比较运算符：
        大于运算符：>
        小于运算符：<
        小于或等于运算符：<=
        大于或等于运算符：>=

        相等运算符：==(不建议使用，用===替换)
        严格相等运算符：===
        不相等运算符：!=
        严格不相等运算符：!==

          比较规则：
            非相等的比较：
                1，若算术运算的两边都是字符串，则按照Unicode码点比较；
                2，原始类型需要先转化为数值，再进行比较；
                3，对象需要先调用valueOf方法，再调用toString方法(若valueOf返回仍是对象才调用)；


     3，布尔运算符：将表达式转化为布尔值；
        取反运算符：!
        且运算符：&&
        或运算符：||
        三元运算符：?:

            两次取反:是将一个值转化为布尔值的简写。例如：!!x等价于Boolean(x)

            且运算符规则：
                1，若第一个运算子的布尔值为true，则返回第二个运算子的值(注意：不是布尔值)；
                2，若第一个运算子的布尔值为false，则返回第一个运算子的值(注意：不是布尔值)；

            且运算符规则：
                1，若第一个运算子的布尔值为true，则返回第一个运算子的值(注意：不是布尔值)；
                2，若第一个运算子的布尔值为false，则返回第二个运算子的值(注意：不是布尔值)；
 */


var a = 1;
var b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
console.log("a=" + a + ", b=" + b); //a=2, b=1

//#00ff00
var color = {
    r: 1, g: 255, b: 1
};

//(1 << 24)确保是6位十六进制的数(前面的数字可能是0)
var result = "#" +
    ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).substring(1);
console.log(result); //#01ff01

console.log(4 >> 1); //2
console.log(-4 >> 1); //-2
//右移运算可以模拟：2的整除运算；
console.log(5 >> 1); //2
console.log(21 >> 2); //5

//内部存储形式：无符号整数格式；
console.log(-1 >>> 0); //4294967295(2^32-1)


/*
    4，二进制位运算：
            二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。
            二进制与运算符（and）：符号为&，表示若两个二进制位都为1，则结果为1，否则为0。
            二进制否运算符（not）：符号为~，表示对一个二进制位取反。
            异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。
            左移运算符（left shift）：符号为<<
            右移运算符（right shift）：符号为>>
            头部补零的右移运算符（zero filled right shift）：符号为>>>

            位运算：直接处理每一个比特是非常底层的运算。好处是计算速度快，但可读性比较差；
                位运算只对整数起作用；若不是整数，会先转化为整数再执行；
                JS用64位浮点数存储数值，但位运算是以32位带符号的整数运算，返回的值也是32位；
                位运算遇到小数，会先取整再进行运算；
                进行位运算的时候，JS会将所有数值转为32位二进制再进行运算；
                JS内部用补码来表示负数；
                    获取一个负数的10进制的值：先减去1，再取反，最后加上负号；(通过10进制负数获取其二进制数，则反着运算)

            否运算符~：将每个二进制位取反。eg：~3 //4
                使用补码算出10进制比较麻烦，简单来说：一个数+取反的值=-1
                二进制否运算取整，是所有取整方法中最快一种；
                对于其他类型(例如：字符串)，先用Number转化为数值，再进行位运算；

            异或运算^：不引入变量的情况下，互换两个变量的值；

            左移运算符<<：将一个数的二进制向左移动n位(包括符号位)，尾部补0；
                使用场景：将RGB颜色转化为HEX非常方便；

            右移运算符>>：将一个数的二进制向右移动n位(包括符号位)，正数首部补0，负数首部补1；
                基本相当于除以2的n次方；

            无符号右移运算符>>>：没有符号位，将一个数的二进制向右移动n位，头部一律补0。
                该运算的结果始终为正数：对于正数的位运算与>>无区别，主要是负数位运算有区别；
                使用场景：最快的查看负数在计算机中的存储形式。例如：1>>>0
 */


var flagA = 1;
var flagB = 2;
var flagC = 4;
var flagD = 8;

//检查是否打开了开关flagC
if (5 & flagC) { //0101 & 0100 = 4
    console.log("打开了开关flagC");
}

var mask = flagA | flagB | flagC; //0111

var flags = 5; //0101
flags = flags | mask; //通过mask，指定打开flags开关
console.log(flags); //0111

var flags1 = 8; //1000
flags1 = flags1 & mask; //通过mask，关闭与mask不一样的开关；
console.log(flags1); //0000

var flag2 = 5; //0101
flag2 = flag2 ^ mask;
console.log(flag2); //0010
//再进行一次异或运算，得到原来的值
console.log(flag2 ^ mask); //0101
/*
    位运算的使用场景：开关作用
 */